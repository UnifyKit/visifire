using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Media.Animation;
using System.Windows.Media;
using Visifire.Commons;
using System.Windows.Controls;
using System.Windows;
using System.Windows.Media.Imaging;
using System.Windows.Interop;
using System.IO;
using System.Windows.Shapes;

namespace Visifire.Charts
{
    internal class HeatMap
    {
        internal static Canvas GetVisualObjectForHeatChart(Panel preExistingPanel, Double width, Double height, DataSeries series, Chart chart)
        {
            if (Double.IsNaN(width) || Double.IsNaN(height) || width <= 0 || height <= 0) return null;

            Canvas visual;
            Canvas contentCanvas;
            RenderHelper.RepareCanvas4Drawing(preExistingPanel as Canvas, out visual, out contentCanvas, width, height);

            var pixelSize = HeatMapHelper.MeasureUIElementPixelSize(contentCanvas);
            int pixelWidth = (int)pixelSize.Width;
            int pixelHeight = (int)pixelSize.Height;
            Bitmap myImage = new Bitmap();
            if (pixelWidth == 0 || pixelHeight == 0)
            {
                //No pixel displayed
            }
            else
            {
                WriteableBitmap writableBtp = new WriteableBitmap(pixelWidth, pixelHeight, HeatMapHelper.DpiX, HeatMapHelper.DpiY, PixelFormats.Bgra32, null);
                byte[] pixels = null;
                double zValueMax = series.HeatMapSurface.ZRange.Max;
                double zValueMin = series.HeatMapSurface.ZRange.Min;
                if (!double.IsNaN(series.ZValueMax))
                {
                    zValueMax = series.ZValueMax;
                }
                if (!double.IsNaN(series.ZValueMin))
                {
                    zValueMin = series.ZValueMin;
                }

                if (series.HeatMapSurface.IsXDateTime)
                {
                    pixels = DrawRectangleWithDateTimeX(writableBtp.PixelWidth, writableBtp.PixelHeight, writableBtp.Format.BitsPerPixel,
                        series.HeatMapSurface, series.InternalHeatMapPalette,
                        (DateTime)chart.AxesX[0].ActualAxisMaximum,
                        (DateTime)chart.AxesX[0].ActualAxisMinimum,
                        (double)chart.AxesY[0].ActualAxisMaximum,
                        (double)chart.AxesY[0].ActualAxisMinimum,
                        series.ZValueUpBoundary,
                        series.ZValueLowBoundary
                        , zValueMax, zValueMin);
                }
                else
                {
                    pixels = DrawRectangleWithDoubleX(writableBtp.PixelWidth, writableBtp.PixelHeight, writableBtp.Format.BitsPerPixel,
                        series.HeatMapSurface, series.InternalHeatMapPalette,
                        (double)chart.AxesX[0].ActualAxisMaximum,
                        (double)chart.AxesX[0].ActualAxisMinimum,
                        (double)chart.AxesY[0].ActualAxisMaximum,
                        (double)chart.AxesY[0].ActualAxisMinimum,
                        series.ZValueUpBoundary,
                        series.ZValueLowBoundary, zValueMax, zValueMin);
                }
                writableBtp.WritePixels(new Int32Rect(0, 0, writableBtp.PixelWidth, writableBtp.PixelHeight), pixels, writableBtp.PixelWidth * writableBtp.Format.BitsPerPixel / 8, 0);
                myImage.Source = writableBtp;
            }
            contentCanvas.Children.Add(myImage);
            return visual;
        }

        internal static Canvas GetVisualObjectForRadarHeatMap(Panel preExistingPanel, Double width, Double height, DataSeries series, Chart chart)
        {
            if (Double.IsNaN(width) || Double.IsNaN(height) || width <= 0 || height <= 0) return null;
            Canvas visual;
            Canvas contentCanvas;
            Canvas labelCanvas = new Canvas();
            Canvas axisCanvas = new Canvas();
            Bitmap myImage = new Bitmap();

            RenderHelper.RepareCanvas4Drawing(preExistingPanel as Canvas, out visual, out contentCanvas, width, height);
            var radarRadian = CalculateRadarRadian(series.StartAngle, series.EndAngle, series.RadarHeatMapOrientation);
            int diameter = 0;
            double radius;
            double innerRadius = 0;
            double rightOffset = 0;
            double topOffset = 0;

            double axisYMax = series.HeatMapSurface.YRange.Max;
            double axisYMin = series.HeatMapSurface.YRange.Min;
            if (!chart.AxesY[0]._isAutoGenerated)
            {
                axisYMax = chart.AxesY[0].AxisMaximumNumeric;
                axisYMin = chart.AxesY[0].AxisMinimumNumeric;
            }

            double zValueMax = series.HeatMapSurface.ZRange.Max;
            double zValueMin = series.HeatMapSurface.ZRange.Min;
            if (!double.IsNaN(series.ZValueMax))
            {
                zValueMax = series.ZValueMax;
            }
            if (!double.IsNaN(series.ZValueMin))
            {
                zValueMin = series.ZValueMin;
            }


            if (series.HeatMapSurface.IsXDateTime)
            {
                DateTime axisXMax = (DateTime)series.HeatMapSurface.XRange.Max;
                DateTime axisXMin = (DateTime)series.HeatMapSurface.XRange.Min;

                if (!chart.AxesX[0]._isAutoGenerated)
                {
                    axisXMax = chart.AxesX[0].AxisMaximumDateTime;
                    axisXMin = chart.AxesX[0].AxisMinimumDateTime;
                }
                labelCanvas = CreateLablesAndTicksForRadarHeatMap(width, height,
                    series.StartAngle * Math.PI / 180.0,
                    axisXMax, axisXMin,
                    radarRadian,
                    series.RadarHeatMapOrientation, series.RadarHeatmapTickInside,
                    ref contentCanvas);

                diameter = CalculateHeatMapRadarDiameter(contentCanvas);
                if (diameter == 0)
                {
                    //No pixel displayed
                }
                else
                {
                    rightOffset = (int)(width / 2 - diameter / 2);
                    topOffset = (int)(height / 2 - diameter / 2);
                    contentCanvas.SetValue(Canvas.RightProperty, rightOffset);
                    contentCanvas.SetValue(Canvas.TopProperty, topOffset);
                    WriteableBitmap wv = new WriteableBitmap(diameter, diameter, HeatMapHelper.DpiX, HeatMapHelper.DpiY, PixelFormats.Bgra32, null);
                    byte[] pixels = null;
                    radius = diameter / 2;
                    innerRadius = radius * series.InnerRadius;
                    pixels = DrawRadarWithDateTimeX(series.StartAngle, series.EndAngle, wv.Format.BitsPerPixel, series.HeatMapSurface, series.InternalHeatMapPalette, diameter, innerRadius, axisXMax, axisXMin, axisYMax, axisYMin, series.RadarHeatMapOrientation, series.ZValueUpBoundary,
                        series.ZValueLowBoundary, zValueMax, zValueMin);
                    wv.WritePixels(new Int32Rect(0, 0, wv.PixelWidth, wv.PixelHeight), pixels, wv.PixelWidth * wv.Format.BitsPerPixel / 8, 0);
                    myImage.Source = wv;
                    axisCanvas = CreateYAxisForCircularHeatMap(chart, series.CHeatMapYAxisPlacement, axisYMax, axisYMin, radius - innerRadius);
                    PlaceYAxisCanvas(axisCanvas, series.CHeatMapYAxisPlacement, radius, innerRadius);
                }
            }
            else
            {
                double axisXMax = (double)series.HeatMapSurface.XRange.Max;
                double axisXMin = (double)series.HeatMapSurface.XRange.Min;

                if (!chart.AxesX[0]._isAutoGenerated)
                {
                    axisXMax = (double)chart.AxesX[0].AxisMaximumNumeric;
                    axisXMin = (double)chart.AxesX[0].AxisMinimumNumeric;
                }
                labelCanvas = CreateLablesAndTicksForRadarHeatMap(width, height,
                    series.StartAngle * Math.PI / 180.0,
                    axisXMax, axisXMin,
                    radarRadian,
                    series.RadarHeatMapOrientation, series.RadarHeatmapTickInside,
                    ref contentCanvas);
                diameter = CalculateHeatMapRadarDiameter(contentCanvas);
                if (diameter == 0)
                {
                    //No pixel displayed
                }
                else
                {
                    rightOffset = (int)(width / 2 - diameter / 2);
                    topOffset = (int)(height / 2 - diameter / 2);
                    contentCanvas.SetValue(Canvas.RightProperty, rightOffset);
                    contentCanvas.SetValue(Canvas.TopProperty, topOffset);
                    WriteableBitmap wv = new WriteableBitmap(diameter, diameter, HeatMapHelper.DpiX, HeatMapHelper.DpiY, PixelFormats.Bgra32, null);
                    byte[] pixels = null;
                    radius = diameter / 2;
                    innerRadius = radius * series.InnerRadius;
                    pixels = DrawRadarWithDoubleX(series.StartAngle, series.EndAngle, wv.Format.BitsPerPixel, series.HeatMapSurface, series.InternalHeatMapPalette, diameter, innerRadius, axisXMax, axisXMin, axisYMax, axisYMin, series.RadarHeatMapOrientation, series.ZValueUpBoundary,
                            series.ZValueLowBoundary
                            , zValueMax, zValueMin);
                    wv.WritePixels(new Int32Rect(0, 0, wv.PixelWidth, wv.PixelHeight), pixels, wv.PixelWidth * wv.Format.BitsPerPixel / 8, 0);
                    myImage.Source = wv;
                    axisCanvas = CreateYAxisForCircularHeatMap(chart, series.CHeatMapYAxisPlacement, axisYMax, axisYMin, radius - innerRadius);
                    PlaceYAxisCanvas(axisCanvas, series.CHeatMapYAxisPlacement, radius, innerRadius);
                }
            }

            contentCanvas.Children.Add(myImage);
            //Ellipse outterBorder = new Ellipse();
            //outterBorder.Width = diameter;
            //outterBorder.Height = diameter;
            //outterBorder.Stroke = Brushes.Gray;
            //outterBorder.StrokeThickness = 1;
            //Ellipse innerBorder = new Ellipse();
            //innerBorder.Width = innerRadius * 2;
            //innerBorder.Height = innerRadius * 2;
            //innerBorder.Stroke = Brushes.Gray;
            //innerBorder.StrokeThickness = 1;
            //innerBorder.SetValue(Canvas.RightProperty, width / 2 - innerRadius);
            //innerBorder.SetValue(Canvas.TopProperty, height / 2 - innerRadius);
            //contentCanvas.Children.Add(outterBorder);
            //visual.Children.Add(innerBorder);
            axisCanvas.SetValue(Canvas.ZIndexProperty, 50001);
            contentCanvas.Children.Add(axisCanvas);
            labelCanvas.SetValue(Canvas.ZIndexProperty, 50001);
            visual.Children.Add(labelCanvas);
            return visual;
        }

        private static double CalculateRadarRadian(double startAngle, double endAngle, RadarHeatmapOrientations orientation)
        {
            var startAngleInRadian = (startAngle * Math.PI / 180.0) % (2 * Math.PI);
            var endAngleInRadian = (endAngle * Math.PI / 180.0) % (2 * Math.PI);
            double result = double.NaN;
            if (orientation == RadarHeatmapOrientations.Clockwise)
            {
                if (startAngleInRadian > endAngleInRadian)
                {
                    result = startAngleInRadian - endAngleInRadian; // Radian

                }
                else if (startAngleInRadian < endAngleInRadian)
                {
                    result = Math.PI * 2 + startAngleInRadian - endAngleInRadian; // Radian
                }
                else
                {
                    result = Math.PI * 2;
                }
            }
            else
            {
                if (startAngleInRadian > endAngleInRadian)
                {
                    result = (Math.PI * 2 - startAngleInRadian) + endAngleInRadian; // Radian
                }
                else if (startAngleInRadian < endAngleInRadian)
                {
                    result = endAngleInRadian - startAngleInRadian; // Radian
                }
                else
                {
                    result = Math.PI * 2;
                }
            }

            if (result > Math.PI * 2)
            {
                result = 2 * Math.PI;
            }
            return result;
        }
        private static int CalculateHeatMapRadarDiameter(Canvas contentCanvas)
        {
            var pixelSize = HeatMapHelper.MeasureUIElementPixelSize(contentCanvas);
            int pixelWidth = (int)pixelSize.Width;
            int pixelHeight = (int)pixelSize.Height;
            return Math.Min(pixelWidth, pixelHeight);
        }
        private static void PlaceYAxisCanvas(Canvas yAxisCanvas, CHeatMapYAxisPlacementTypes placement, double radius, double innerRadius)
        {
            switch (placement)
            {
                case CHeatMapYAxisPlacementTypes.Left:
                    yAxisCanvas.SetValue(Canvas.LeftProperty, 0.0);
                    yAxisCanvas.SetValue(Canvas.TopProperty, radius);
                    break;
                case CHeatMapYAxisPlacementTypes.Right:
                    yAxisCanvas.SetValue(Canvas.LeftProperty, radius + innerRadius);
                    yAxisCanvas.SetValue(Canvas.TopProperty, radius);
                    break;
                case CHeatMapYAxisPlacementTypes.Top:
                    yAxisCanvas.SetValue(Canvas.LeftProperty, radius);
                    yAxisCanvas.SetValue(Canvas.TopProperty, 0.0);
                    break;
                case CHeatMapYAxisPlacementTypes.Bottom:
                    yAxisCanvas.SetValue(Canvas.LeftProperty, radius);
                    yAxisCanvas.SetValue(Canvas.TopProperty, radius + innerRadius);
                    break;
                default:
                    throw new Exception();
            }
        }

        private static double YAxisTickSpace = 20;
        private static Canvas CreateYAxisForCircularHeatMap(Chart chart, CHeatMapYAxisPlacementTypes placement, double axisYMax, double axisYMin, double length)
        {
            Canvas yAxisCanvas = new Canvas();
            Ticks ticks = new Ticks();
            AxisLabels lables = new AxisLabels();

            decimal axisYMaxInDe = (decimal)axisYMax;
            decimal axisYMinInDe = (decimal)axisYMin;

            int noMaxInteval = (Int32)(length / YAxisTickSpace);
            if (noMaxInteval < 1)
            {
                noMaxInteval = 1;
            }

            double intervalValue = AxisIntervalTool.GenerateDefaultInterval(ref axisYMaxInDe, ref axisYMinInDe, true, true, noMaxInteval); //IntervalValue equals to 0 cause infinite loop problem
            ticks.IsNotificationEnable = false;
            ticks.Maximum = axisYMax;
            ticks.Minimum = axisYMin;
            ticks.DataMaximum = axisYMax;
            ticks.DataMinimum = axisYMin;
            ticks.IsNotificationEnable = true;
            ticks.LineColor = Brushes.Black;
            ticks.LineThickness = 0.5;
            ticks.Interval = intervalValue;
            var axis = new Axis();
            axis._isAutoGenerated = true;
            axis.Chart = chart;
            axis.XValueType = ChartValueTypes.Numeric;
            PlotDetails pl = new PlotDetails(null);
            pl.ChartOrientation = ChartOrientationType.Vertical;
            axis.PlotDetails = pl;
            lables.Maximum = axisYMax;
            lables.Minimum = axisYMin;
            lables.DataMaximum = axisYMax;
            lables.DataMinimum = axisYMin;
            lables.ParentAxis = axis;
            lables.Parent = axis;
            lables.InternalRows = (Int32)lables.Rows;
            lables.Interval = intervalValue;
            lables.Chart = chart;
            lables.AxisLabelContentDictionary = new Dictionary<double, string>();
            axis.AxisType = AxisTypes.Primary;
            axis.Interval = intervalValue;
            axis.InternalInterval = intervalValue;
            ticks.ParentAxis = axis;

            Line axisLine = new Line();
            axisLine.SnapsToDevicePixels = true;
            axisLine.Stroke = Brushes.Black;
            axisLine.StrokeThickness = 1;
            switch (placement)
            {
                case CHeatMapYAxisPlacementTypes.Right:
                    ticks.SetParms(PlacementTypes.Bottom, length, Double.NaN);
                    lables.Width = length;
                    lables.Placement = PlacementTypes.Bottom;
                    axis.AxisOrientation = AxisOrientation.Horizontal;
                    axis.AxisRepresentation = AxisRepresentations.AxisX;
                    axisLine.X1 = 0;
                    axisLine.Y1 = 0;
                    axisLine.X2 = length;
                    axisLine.Y2 = 0;

                    break;
                case CHeatMapYAxisPlacementTypes.Left:
                    ticks.SetParms(PlacementTypes.Bottom, length, Double.NaN);
                    lables.Width = length;
                    lables.Placement = PlacementTypes.Bottom;

                    axis.AxisOrientation = AxisOrientation.Horizontal;
                    axis.AxisRepresentation = AxisRepresentations.AxisX;
                    axisLine.X1 = 0;
                    axisLine.Y1 = 0;
                    axisLine.X2 = length;
                    axisLine.Y2 = 0;
                    break;
                case CHeatMapYAxisPlacementTypes.Top:
                    ticks.SetParms(PlacementTypes.Left, Double.NaN, length);
                    lables.Height = length;
                    lables.Placement = PlacementTypes.Left;
                    axis.AxisOrientation = AxisOrientation.Vertical;
                    axis.AxisType = AxisTypes.Primary;
                    axis.AxisRepresentation = AxisRepresentations.AxisY;
                    axisLine.X1 = 0;
                    axisLine.Y1 = 0;
                    axisLine.X2 = 0;
                    axisLine.Y2 = length;
                    break;
                case CHeatMapYAxisPlacementTypes.Bottom:
                    ticks.SetParms(PlacementTypes.Left, Double.NaN, length);
                    lables.Height = length;
                    lables.Placement = PlacementTypes.Left;
                    axis.AxisOrientation = AxisOrientation.Vertical;
                    axis.AxisType = AxisTypes.Primary;
                    axis.AxisRepresentation = AxisRepresentations.AxisY;
                    axisLine.X1 = 0;
                    axisLine.Y1 = 0;
                    axisLine.X2 = 0;
                    axisLine.Y2 = length;
                    break;
                default:
                    throw new Exception();
            }

            ticks.CreateVisualObject();
            lables.CreateVisualObject();

            switch (placement)
            {
                case CHeatMapYAxisPlacementTypes.Top:
                case CHeatMapYAxisPlacementTypes.Bottom:
                    lables.Visual.SetValue(Canvas.LeftProperty, 8.0);
                    break;
                case CHeatMapYAxisPlacementTypes.Left:
                case CHeatMapYAxisPlacementTypes.Right:
                    lables.Visual.SetValue(Canvas.TopProperty, 8.0);
                    break;
                default:
                    throw new Exception();
            }

            yAxisCanvas.Children.Add(axisLine);
            yAxisCanvas.Children.Add(lables.Visual);
            yAxisCanvas.Children.Add(ticks.Visual);
            return yAxisCanvas;
        }

        public static int lableOffsetFromBoundary = 4;
        public static int lableOffsetFromContent = 0;
        public static double minLableIntervalInRadian = Math.PI / 6.0;

        /// <summary>
        //RadianValue must be 1/2 PI, PI,2PI
        //Difference between AxisMaxValue and AxisMinValue must be 90 mutiple.
        //AxisMinValue must start from 0;
        /// </summary>
        private static double GetQualifiedStandardIntervalDistanceInRadian(double weigth, double height)
        {
            var diameter = Math.Min(weigth, height);
            if (diameter < 150)
            {
                return Math.PI / 2.0;
            }
            else if (diameter < 700)
            {
                return Math.PI / 6.0;
            }
            else
            {
                return Math.PI / 12.0;
            }
        }

        private static bool ValidateStandardRadarChart(double axisMax, double axisMin, double radian)
        {
            if (axisMin != 0)
            {
                return false;
            }
            if (radian % (Math.PI / 2) != 0)
            {
                return false;
            }
            if ((axisMax - axisMin) % 90 != 0)
            {
                return false;
            }
            return true;
        }

        private static int CalculateNoOfInterval(double max, double min, double readableMin, double interval)
        {
            int noOfInterval = 0;
            if (min % interval != 0)
            {
                while (readableMin < min)
                {
                    readableMin += interval;
                    noOfInterval++;
                }
            }
            else
            {
                readableMin = min;
            }

            while (readableMin < max)
            {
                readableMin += interval;
                noOfInterval++;
            }
            return noOfInterval;
        }

        private static int CalculateDateTimeNoOfInterval(DateTime start, DateTime end, TimeSpan interval)
        {
            int noOfInterval = 0;
            while (start < end)
            {
                start = start.Add(interval);
                noOfInterval++;
            }
            return noOfInterval;
        }

        private static Canvas CreateLablesAndTicksForRadarHeatMap(double width, double height, double startAngleInRadian, double axisXMax, double axisXMin, double radian, RadarHeatmapOrientations orientation, bool isTicksInside, ref Canvas contentCanvas)
        {
            Canvas visual = new Canvas() { Height = height, Width = width };
            List<TextBlock> labelsToBePlaced = new List<TextBlock>();
            List<Line> ticks = new List<Line>();
            Double lableSize = 20;

            int maxNoOfIntervalLables = 0;
            int noOfLables;
            double increment = 0;
            double nextToFirstTickValue = double.NaN;
            double nextToFirstTickRadianOffset = 0;
            double nextToLastTickRadianOffset = 0;

            if (ValidateStandardRadarChart(axisXMax, axisXMin, radian))
            {
                maxNoOfIntervalLables = (int)(radian / GetQualifiedStandardIntervalDistanceInRadian(width, height));
                increment = Math.Round((axisXMax - axisXMin) / maxNoOfIntervalLables, 4);
                noOfLables = maxNoOfIntervalLables + 1;

            }
            else
            {
                maxNoOfIntervalLables = (int)(radian / minLableIntervalInRadian);

                decimal axisXMaxInDe = (decimal)axisXMax;
                decimal axisXMinInDe = (decimal)axisXMin;

                increment = AxisIntervalTool.GenerateDefaultInterval(ref axisXMaxInDe, ref axisXMinInDe, true, false, maxNoOfIntervalLables);
                noOfLables = CalculateNoOfInterval(axisXMax, axisXMin, (double)axisXMinInDe, increment) + 1;
                if ((decimal)axisXMin != axisXMinInDe)
                {

                    double diff = ((double)axisXMinInDe - axisXMin);
                    if (Math.Abs(diff) != increment)
                    {
                        if (diff > 0)
                        {
                            nextToFirstTickValue = diff + axisXMin;
                            nextToFirstTickRadianOffset = diff * (radian / (axisXMax - axisXMin));
                        }
                        else
                        {
                            nextToFirstTickValue = increment + diff + axisXMin;
                            nextToFirstTickRadianOffset = (increment + diff) * (radian / (axisXMax - axisXMin));
                        }
                    }
                    if (!double.IsNaN(nextToFirstTickValue)) // interval between frist and second is not same as increment
                    {
                        double nextToLastValue = nextToFirstTickValue + (noOfLables - 2) * increment;
                        if (nextToLastValue > axisXMax) // interval between last and next to last is not same as increment
                        {
                            nextToLastValue = nextToFirstTickValue + (noOfLables - 3) * increment;
                        }
                        nextToLastTickRadianOffset = (axisXMax - nextToLastValue) * (radian / (axisXMax - axisXMin));
                    }
                    else
                    {
                        double nextToLastValue = axisXMin + (noOfLables - 1) * increment;
                        if (nextToLastValue > axisXMax) // interval between last and next to last is not same as increment
                        {
                            nextToLastValue = axisXMin + (noOfLables - 2) * increment;
                        }
                        nextToLastTickRadianOffset = (axisXMax - nextToLastValue) * (radian / (axisXMax - axisXMin));
                    }
                }
            }

            labelsToBePlaced.Add(new TextBlock() { Text = axisXMin.ToString(), TextAlignment = TextAlignment.Center });
            noOfLables--;
            double startValue = axisXMin;
            if (!double.IsNaN(nextToFirstTickValue))
            {
                labelsToBePlaced.Add(new TextBlock() { Text = nextToFirstTickValue.ToString(), TextAlignment = TextAlignment.Center });
                startValue = nextToFirstTickValue;
                noOfLables--;
            }

            noOfLables--;//For last one
            if (noOfLables > 0)
            {
                for (int i = 1; i <= noOfLables; i++)
                {
                    labelsToBePlaced.Add(new TextBlock() { Text = (startValue + increment * i).ToString(), TextAlignment = TextAlignment.Center });
                }
            }


            if (radian != 2 * Math.PI)
            {
                labelsToBePlaced.Add(new TextBlock() { Text = axisXMax.ToString(), TextAlignment = TextAlignment.Center });
            }
            else //Don't show the last lable when is a complete circular
            {
                labelsToBePlaced.Add(new TextBlock() { Text = "", TextAlignment = TextAlignment.Center });
            }


            foreach (TextBlock label in labelsToBePlaced)
            {
                label.Measure(new Size(double.MaxValue, double.MaxValue));
                lableSize = Math.Max(lableSize, label.DesiredSize.Width);
                visual.Children.Add(label);

                Line tick = new Line();
                ticks.Add(tick);
                visual.Children.Add(tick);
            }

            Double contentCanvasDiameter = 0;
            Double labelEllipseWidth = 0;
            Double labelEllipseHeight = 0;

            contentCanvasDiameter = Math.Min(width, height) - ((lableSize + lableOffsetFromBoundary + lableOffsetFromContent) * 2);

            if (contentCanvasDiameter < 0)
            {
                contentCanvas.Height = 0;
                contentCanvasDiameter = 0;
                visual.Children.Clear();
                return visual;
            }

            labelEllipseWidth = Math.Abs(contentCanvasDiameter) + lableSize * 2 + lableOffsetFromContent * 2;
            labelEllipseHeight = labelEllipseWidth;

            PositionLabels(labelsToBePlaced, ticks, startAngleInRadian, radian, nextToFirstTickRadianOffset, nextToLastTickRadianOffset, orientation, isTicksInside, new Size(Math.Abs(contentCanvasDiameter), Math.Abs(contentCanvasDiameter)), new Size(Math.Abs(labelEllipseWidth), Math.Abs(labelEllipseHeight)), new Size(width, height));
            //PositionTicks(ticks, startAngleInRadian, radian, nextToFirstTickRadianOffset, nextToLastTickRadianOffset, orientation, isTicksInside, new Size(Math.Abs(contentCanvasDiameter), Math.Abs(contentCanvasDiameter)), new Size(width, height));
            contentCanvas.Width = Math.Abs(contentCanvasDiameter);
            contentCanvas.Height = Math.Abs(contentCanvasDiameter);
            return visual;
        }

        private static Canvas CreateLablesAndTicksForRadarHeatMap(double width, double height, double startAngleInRadian, DateTime axisXMax, DateTime axisXMin, double radian, RadarHeatmapOrientations orientation, bool isTicksInside, ref Canvas contentCanvas)
        {
            Canvas visual = new Canvas() { Height = height, Width = width };
            List<TextBlock> labelsToBePlaced = new List<TextBlock>();
            List<Line> ticks = new List<Line>();

            double nextToFirstTickRadianOffset = 0; //If 0, it means it does not have special space between first and nextToFirst
            double nextToLastTickRadianOffset = 0; //If 0, it means it does not have special space between last and nextToLast


            Double lableSize = 20;

            int maxNoLables = (int)(radian / minLableIntervalInRadian);
            ValidTimeAxisSettings timeSettings = AxisIntervalTool.GenerateDefaultDateTimeInterval(axisXMin, axisXMax, maxNoLables);
            int noOfLables = CalculateDateTimeNoOfInterval(axisXMin, axisXMax, timeSettings.TimeSpan) + 1;

            DateTime readableAxisMax = axisXMin.AddDays(timeSettings.TimeSpan.TotalDays * (noOfLables - 1));
            if (readableAxisMax != axisXMax)
            {
                nextToLastTickRadianOffset = (readableAxisMax - axisXMax).TotalDays * (radian / (axisXMax - axisXMin).TotalDays);
            }

            double incr = timeSettings.TimeSpan.TotalDays;

            //double incr = (axisXMax - axisXMin).TotalDays / noLables;
            //if (radian == 2 * Math.PI)    
            //{
            //    noLables += 1;
            //}

            if (noOfLables > 0)
            {
                for (int i = 0; i < noOfLables - 1; i++)
                {
                    labelsToBePlaced.Add(new TextBlock() { Text = string.Format("{0:" + timeSettings.DateFormat + "}", axisXMin.AddDays(incr * i)), TextAlignment = TextAlignment.Center });
                }
                if (radian != Math.PI * 2)
                {
                    labelsToBePlaced.Add(new TextBlock() { Text = string.Format("{0:" + timeSettings.DateFormat + "}", axisXMax), TextAlignment = TextAlignment.Center });
                }
                else
                {
                    labelsToBePlaced.Add(new TextBlock() { Text = "", TextAlignment = TextAlignment.Center });

                }
            }
            else
            {
                labelsToBePlaced.Add(new TextBlock() { Text = axisXMax.ToShortDateString(), TextAlignment = TextAlignment.Center });
                labelsToBePlaced.Add(new TextBlock() { Text = axisXMin.ToShortDateString(), TextAlignment = TextAlignment.Center });
            }

            foreach (TextBlock label in labelsToBePlaced)
            {
                label.Measure(new Size(double.MaxValue, double.MaxValue));
                lableSize = Math.Max(lableSize, label.DesiredSize.Width);
                visual.Children.Add(label);

                Line tick = new Line();
                ticks.Add(tick);
                visual.Children.Add(tick);
            }

            Double contentCanvasDiameter = 0;
            Double labelEllipseWidth = 0;
            Double labelEllipseHeight = 0;

            contentCanvasDiameter = Math.Min(width, height) - ((lableSize + lableOffsetFromBoundary + lableOffsetFromContent) * 2);

            if (contentCanvasDiameter < 0)
            {
                contentCanvas.Height = 0;
                contentCanvasDiameter = 0;
                visual.Children.Clear();
                return visual;
            }

            labelEllipseWidth = Math.Abs(contentCanvasDiameter) + lableSize * 2 + lableOffsetFromContent * 2;
            labelEllipseHeight = labelEllipseWidth;

            PositionLabels(labelsToBePlaced, ticks, startAngleInRadian, radian, nextToFirstTickRadianOffset, nextToLastTickRadianOffset, orientation, isTicksInside, new Size(Math.Abs(contentCanvasDiameter), Math.Abs(contentCanvasDiameter)), new Size(Math.Abs(labelEllipseWidth), Math.Abs(labelEllipseHeight)), new Size(width, height));
            //PositionTicks(ticks, startAngleInRadian, radian, nextToFirstTickRadianOffset, nextToLastTickRadianOffset, orientation, isTicksInside, new Size(Math.Abs(contentCanvasDiameter), Math.Abs(contentCanvasDiameter)), new Size(width, height));
            contentCanvas.Width = Math.Abs(contentCanvasDiameter);
            contentCanvas.Height = Math.Abs(contentCanvasDiameter);
            return visual;
        }

        private static void DrawTick(Line tick, double radian, RadarHeatmapOrientations orientation, bool isTickInside)
        {
            double lineLength = 6;
            tick.Stroke = Brushes.Black;
            tick.StrokeThickness = 1;
            tick.SnapsToDevicePixels = true;
            if (isTickInside)
            {
                tick.X2 = Math.Cos(radian + Math.PI) * lineLength;
                tick.Y2 = -Math.Sin(radian + Math.PI) * lineLength;
            }
            else
            {
                tick.X2 = Math.Cos(radian) * lineLength;
                tick.Y2 = -Math.Sin(radian) * lineLength;
            }
        }

        private static void PositionLabels(List<TextBlock> lables, List<Line> ticks,
            double startAngleInRadian, double radian,
            double nextToFirstRadianOffset, double nextToLastRaidianOffset,
            RadarHeatmapOrientations orientation,
            bool isTickInside,
            Size contentSize,
            Size lablesEllipseSize, Size visualCanvasSize)
        {
            Double xRadiusLabel = lablesEllipseSize.Width / 2;
            Double yRadiusLabel = lablesEllipseSize.Height / 2;
            Double xRadiusTick = contentSize.Width / 2;
            Double yRadiusTick = contentSize.Height / 2;
            Point center;

            center = new Point(visualCanvasSize.Width / 2, visualCanvasSize.Height / 2);

            Double stopAngle;
            int noInterval = lables.Count - 2;
            int leftLableCount = lables.Count;

            PositionRadarAxisElement(center, lables[0], xRadiusLabel, startAngleInRadian);
            DrawTick(ticks[0], startAngleInRadian, orientation, isTickInside);
            PositionRadarAxisElement(center, ticks[0], xRadiusTick, startAngleInRadian);
            leftLableCount--;


            if (nextToLastRaidianOffset != 0)
            {
                if (orientation == RadarHeatmapOrientations.Clockwise)
                {
                    PositionRadarAxisElement(center, lables[lables.Count - 1], xRadiusLabel, startAngleInRadian - radian);
                    DrawTick(ticks[0], startAngleInRadian, orientation, isTickInside);
                    PositionRadarAxisElement(center, ticks[ticks.Count - 1], xRadiusTick, startAngleInRadian - radian);
                }
                else
                {
                    PositionRadarAxisElement(center, lables[lables.Count - 1], xRadiusLabel, startAngleInRadian + radian);
                    DrawTick(ticks[ticks.Count - 1], startAngleInRadian + radian, orientation, isTickInside);
                    PositionRadarAxisElement(center, ticks[ticks.Count - 1], xRadiusTick, startAngleInRadian + radian);
                }
                leftLableCount--;
            }


            int placedAfterFristOne = 0;
            if (nextToFirstRadianOffset != 0)
            {
                if (orientation == RadarHeatmapOrientations.Clockwise)
                {
                    startAngleInRadian = startAngleInRadian - nextToFirstRadianOffset;
                }
                else
                {
                    startAngleInRadian = startAngleInRadian + nextToFirstRadianOffset;

                }
                PositionRadarAxisElement(center, lables[1], xRadiusLabel, startAngleInRadian);
                DrawTick(ticks[1], startAngleInRadian, orientation, isTickInside);
                PositionRadarAxisElement(center, ticks[1], xRadiusTick, startAngleInRadian);
                leftLableCount--;
                placedAfterFristOne++;
            }

            double intermediateRadian = (radian - nextToFirstRadianOffset - nextToLastRaidianOffset) / (leftLableCount);

            if (orientation == RadarHeatmapOrientations.Clockwise)
            {
                startAngleInRadian -= intermediateRadian;
            }
            else
            {
                startAngleInRadian += intermediateRadian;

            }

            for (int i = 1 + placedAfterFristOne; i <= leftLableCount + placedAfterFristOne; i++)
            {
                if (orientation == RadarHeatmapOrientations.Clockwise)
                {
                    stopAngle = startAngleInRadian - intermediateRadian;
                }
                else
                {
                    stopAngle = startAngleInRadian + intermediateRadian;

                }
                if (stopAngle > Math.PI * 2)
                    stopAngle -= Math.PI * 2;

                if (stopAngle < 0)
                    stopAngle = Math.PI * 2 + stopAngle;

                PositionRadarAxisElement(center, lables[i], xRadiusLabel, startAngleInRadian);
                DrawTick(ticks[i], startAngleInRadian, orientation, isTickInside);
                PositionRadarAxisElement(center, ticks[i], xRadiusTick, startAngleInRadian);

                startAngleInRadian = stopAngle;
            }
        }

        private static void PositionTicks(List<Line> ticks, double startAngleInRadian, double radian, double nextToFirstRadianOffset, double nextToLastRaidianOffset, RadarHeatmapOrientations orientation, bool isInside, Size contentSize, Size visualCanvasSize)
        {
            //Double xRadiusTick = contentSize.Width / 2;
            //Double yRadiusTick = contentSize.Height / 2;
            //double LineLength = 6;
            //Point center;

            //center = new Point(visualCanvasSize.Width / 2, visualCanvasSize.Height / 2);

            //Double stopAngle;
            //int noInterval = ticks.Count - 1;
            //if (radian == 2 * Math.PI)
            //{
            //    noInterval = ticks.Count;
            //}

            //foreach (Line tick in ticks)
            //{
            //    tick.Stroke = Brushes.Black;
            //    tick.StrokeThickness = 1;
            //    tick.SnapsToDevicePixels = true;

            //    if (orientation == RadarHeatmapOrientations.Clockwise)
            //    {
            //        stopAngle = startAngleInRadian - radian / noInterval;
            //    }
            //    else
            //    {
            //        stopAngle = startAngleInRadian + radian / noInterval;
            //    }

            //    if (stopAngle > Math.PI * 2)
            //        stopAngle -= Math.PI * 2;

            //    if (stopAngle < 0)
            //        stopAngle = Math.PI * 2 + stopAngle;

            //    Double x = center.X + xRadiusTick * Math.Cos(startAngleInRadian);
            //    Double y = center.Y - yRadiusTick * Math.Sin(startAngleInRadian);

            //    tick.X1 = 0;
            //    tick.Y1 = 0;
            //    if (isInside)
            //    {
            //        tick.X2 = Math.Cos(startAngleInRadian + Math.PI) * LineLength;
            //        tick.Y2 = -Math.Sin(startAngleInRadian + Math.PI) * LineLength;
            //    }
            //    else
            //    {
            //        tick.X2 = Math.Cos(startAngleInRadian) * LineLength;
            //        tick.Y2 = -Math.Sin(startAngleInRadian) * LineLength;
            //    }



            //    tick.SetValue(Canvas.LeftProperty, x);
            //    tick.SetValue(Canvas.TopProperty, y);
            //    startAngleInRadian = stopAngle;
            //}
        }


        private static void PositionRadarAxisElement(Point center, FrameworkElement element, double radius, double radian)
        {

            double x = center.X + radius * Math.Cos(radian);
            double y = center.Y - radius * Math.Sin(radian);


            if (x - element.DesiredSize.Width / 2 < 0)
                x = 0;
            else
                x -= element.DesiredSize.Width / 2;

            if (y - element.DesiredSize.Height / 2 < 0)
                y = 0;
            else
                y -= element.DesiredSize.Height / 2;

            element.SetValue(Canvas.LeftProperty, x);
            element.SetValue(Canvas.TopProperty, y);
        }



        private static Color EdgeColor = Color.FromArgb(100, 200, 200, 200);
        private static double CalculateRadian(RadarHeatmapOrientations orientation, double degreeInRadians, double startAngleInRadians, double endAngleInRadians)
        {
            double twoPI = Math.PI * 2;

            if (orientation == RadarHeatmapOrientations.Clockwise)
            {
                if (startAngleInRadians > endAngleInRadians)
                {
                    if (degreeInRadians <= startAngleInRadians && degreeInRadians >= endAngleInRadians)
                    {
                        return startAngleInRadians - degreeInRadians;
                    }
                }
                else if (startAngleInRadians < endAngleInRadians)
                {
                    if (startAngleInRadians >= degreeInRadians)
                    {
                        return startAngleInRadians - degreeInRadians;
                    }
                    else if (degreeInRadians >= endAngleInRadians)
                    {
                        return twoPI - degreeInRadians + startAngleInRadians;
                    }
                }
                else if (startAngleInRadians == endAngleInRadians)
                {
                    if (degreeInRadians > startAngleInRadians)
                    {
                        return twoPI - degreeInRadians + startAngleInRadians;
                    }
                    else if (degreeInRadians < startAngleInRadians)
                    {
                        return startAngleInRadians - degreeInRadians;
                    }
                    else if (degreeInRadians == startAngleInRadians)
                    {
                        return 0;
                    }
                }
            }
            else
            {
                if (startAngleInRadians > endAngleInRadians)
                {
                    if (degreeInRadians >= startAngleInRadians)
                    {
                        return degreeInRadians - startAngleInRadians;
                    }
                    else if (degreeInRadians <= endAngleInRadians)
                    {
                        return twoPI - startAngleInRadians + degreeInRadians;
                    }
                }
                else if (startAngleInRadians < endAngleInRadians)
                {
                    if (degreeInRadians >= startAngleInRadians && degreeInRadians <= endAngleInRadians)
                    {
                        return degreeInRadians - startAngleInRadians;
                    }
                }
                else if (startAngleInRadians == endAngleInRadians)
                {
                    if (degreeInRadians > startAngleInRadians)
                    {
                        return degreeInRadians - startAngleInRadians;

                    }
                    else if (degreeInRadians < startAngleInRadians)
                    {
                        return twoPI + degreeInRadians - startAngleInRadians;
                    }
                    else if (degreeInRadians == startAngleInRadians)
                    {
                        return 0;
                    }
                }
            }
            return double.NaN;
        }

        private static byte[] DrawRadarWithDoubleX(double startAngle, double endAngle,
            int bpp, AbstractSurface surface, HeatMapPalette palette, int diameter, double innerRadius,
            double axisXMax, double axisXMin,
            double axisYMax, double axisYMin,
            RadarHeatmapOrientations orientation, double zValueUpBoundary, double zValueLowBoundary, double zValueMax, double zValueMin)
        {
            double twoPI = 2 * Math.PI;
            double radius = diameter / 2;
            var startAngleInRadians = (startAngle * (Math.PI / 180)) % (2 * Math.PI);
            var endAngleInRadians = (endAngle * (Math.PI / 180)) % (2 * Math.PI);
            double xRangeFactor;
            xRangeFactor = (axisXMax - axisXMin) / (radius * CalculateRadarRadian(startAngle, endAngle, orientation)); // Radian


            int bytesPerPixel = bpp / 8;
            Vector center = new Vector((diameter / 2) - 0.5, (diameter / 2) - 0.5);

            Byte[] pixels = new byte[diameter * diameter * bytesPerPixel];

            double yRangeFactor = (axisYMax - axisYMin) / ((diameter / 2) - innerRadius);
            double zRangeFactor = (palette.ColorCount - 1) / (zValueMax - zValueMin);

            for (int y = 0; y < diameter; y++)
            {
                int writeIndex = y * diameter * bytesPerPixel;
                for (int x = 0; x < diameter; x++)
                {
                    Vector pos = new Vector(x, y);
                    Vector newVec = pos - center;
                    var distance = newVec.Length;
                    double degreeInRadians;
                    degreeInRadians = (Math.Atan2(-newVec.Y, newVec.X) + 2 * Math.PI) % twoPI;

                    if (distance <= radius && distance > innerRadius)
                    {
                        double inputX = 0;
                        double radian = CalculateRadian(orientation, degreeInRadians, startAngleInRadians, endAngleInRadians);
                        if (Double.IsNaN(radian))
                        {
                            writeIndex += bytesPerPixel;
                            continue;
                        }
                        else
                        {
                            inputX = radian * radius * xRangeFactor + axisXMin;
                        }

                        if (inputX >= (double)surface.XRange.Min
                          && inputX < (double)surface.XRange.Max)
                        {
                            double inputY = (distance - innerRadius) * yRangeFactor + axisYMin;
                            if (inputY >= surface.YRange.Min
                           && inputY < surface.YRange.Max)
                            {
                                var zds = surface.GetValue(inputX, inputY);
                                if (double.IsNaN(zds) || zds > zValueMax || zds < zValueMin)
                                {
                                    writeIndex += bytesPerPixel;
                                }
                                else
                                {
                                    if (zds <= zValueUpBoundary && zds >= zValueLowBoundary)
                                    {
                                        zds = (zds - zValueMin) * zRangeFactor;
                                        var c = palette.GetColor((int)zds);
                                        byte[] bArray = BitConverter.GetBytes(c);
                                        foreach (byte b in bArray)
                                        {
                                            pixels[writeIndex] = b;
                                            writeIndex++;
                                        }
                                    }
                                    else
                                    {
                                        writeIndex += bytesPerPixel;
                                    }
                                }
                            }
                            else
                            {
                                writeIndex += bytesPerPixel;
                            }

                        }
                        else
                        {
                            writeIndex += bytesPerPixel;
                        }
                    }
                    else
                    {
                        writeIndex += bytesPerPixel;
                    }
                }
            }
            return pixels;
        }

        private static byte[] DrawRadarWithDateTimeX(double startAngle, double endAngle, int bpp, AbstractSurface surface, HeatMapPalette palette,
            int diameter, double innerRadius, DateTime axisXMax, DateTime axisXMin,
             double axisYMax, double axisYMin, RadarHeatmapOrientations orientation, double zValueUpBoundary, double zValueLowBoundary, double zValueMax, double zValueMin)
        {

            var startAngleInRadians = (startAngle * (Math.PI / 180)) % (2 * Math.PI);
            var endAngleInRadians = (endAngle * (Math.PI / 180)) % (2 * Math.PI);
            double radius = diameter / 2;
            double twoPI = 2 * Math.PI;
            double xRangeFactor;
            TimeSpan ts = axisXMax - axisXMin;

            xRangeFactor = ts.TotalDays / (radius * CalculateRadarRadian(startAngle, endAngle, orientation)); // Radian

            int bytesPerPixel = bpp / 8;
            Vector center = new Vector((diameter / 2) - 0.5, (diameter / 2) - 0.5);
            Byte[] pixels = new byte[diameter * diameter * bytesPerPixel];
            double yRangeFactor = (axisYMax - axisYMin) / ((diameter / 2) - innerRadius);
            double zRangeFactor = (palette.ColorCount - 1) / (zValueMax - zValueMin);


            for (int y = 0; y < diameter; y++)
            {
                int writeIndex = y * diameter * bytesPerPixel;
                for (int x = 0; x < diameter; x++)
                {
                    Vector pos = new Vector(x, y);
                    Vector newVec = pos - center;
                    var distance = newVec.Length;
                    double degreeInRadians;
                    degreeInRadians = (Math.Atan2(-newVec.Y, newVec.X) + 2 * Math.PI) % twoPI;

                    if (distance <= radius && distance > innerRadius)
                    {
                        DateTime inputX;
                        double addedDays;
                        double radian = CalculateRadian(orientation, degreeInRadians, startAngleInRadians, endAngleInRadians);
                        if (Double.IsNaN(radian))
                        {
                            writeIndex += bytesPerPixel;
                            continue;
                        }
                        else
                        {
                            addedDays = radian * radius * xRangeFactor;
                        }

                        inputX = axisXMin.AddDays(addedDays);

                        if (inputX >= (DateTime)surface.XRange.Min
                            && inputX < (DateTime)surface.XRange.Max)
                        {
                            double inputY = (distance - innerRadius) * yRangeFactor + axisYMin;
                            if (inputY >= surface.YRange.Min
                            && inputY < surface.YRange.Max)
                            {
                                var zds = surface.GetValue(inputX, inputY);


                                if (double.IsNaN(zds) || zds > zValueMax || zds < zValueMin)
                                {
                                    writeIndex += bytesPerPixel;
                                }
                                else
                                {
                                    if (zds <= zValueUpBoundary && zds >= zValueLowBoundary)
                                    {
                                        zds = (zds - zValueMin) * zRangeFactor;
                                        var c = palette.GetColor((int)zds);
                                        byte[] bArray = BitConverter.GetBytes(c);
                                        foreach (byte b in bArray)
                                        {
                                            pixels[writeIndex] = b;
                                            writeIndex++;
                                        }
                                    }
                                    else
                                    {
                                        writeIndex += bytesPerPixel;
                                    }
                                }
                            }
                            else
                            {
                                writeIndex += bytesPerPixel;
                            }

                        }
                        else
                        {
                            writeIndex += bytesPerPixel;
                        }
                    }
                    else
                    {
                        writeIndex += bytesPerPixel;
                    }
                }
            }
            return pixels;
        }


        private static byte[] DrawRectangleWithDateTimeX(int chartWidth, int chartHeight, int bpp, AbstractSurface surface,
            HeatMapPalette palette, DateTime axisXMax, DateTime axisXMin, double axisYMax, double axisYMin,
            double zValueUpBoundary,
            double zValueLowBoundary, double zValueMax, double zValueMin)
        {
            int bytesPerPixel = bpp / 8;
            Byte[] pixels = new byte[chartHeight * chartWidth * bytesPerPixel];
            double xRangeFactor = (axisXMax - axisXMin).TotalDays / chartWidth;
            double xRangeFactorInMid = xRangeFactor / 2;
            double yRangeFactor = (axisYMax - axisYMin) / chartHeight;
            double zRangeFactor = (palette.ColorCount - 1) / (zValueMax - zValueMin);
            var xRangeMin = (DateTime)surface.XRange.Min;
            var xRangeMax = (DateTime)surface.XRange.Max;
            var yPixelsNum = (chartHeight - 1);
            var xAxisByteOffset = chartWidth * bytesPerPixel;

            for (int y = 0; y < chartHeight; y++)
            {
                {
                    double yds = (y + 0.5) * yRangeFactor + axisYMin;
                    double xds = -xRangeFactorInMid;
                    int writeIndex = (yPixelsNum - y) * xAxisByteOffset;
                    for (int x = 0; x < chartWidth; x++)
                    {
                        xds += xRangeFactor;
                        DateTime input = axisXMin.AddDays(xds);
                        if (input >= xRangeMin
                            && input < xRangeMax
                            && yds >= surface.YRange.Min
                            && yds < surface.YRange.Max)
                        {
                            var zds = surface.GetValue(input, yds);
                            if (double.IsNaN(zds) || zds > zValueMax || zds < zValueMin)
                            {
                                writeIndex += bytesPerPixel;
                            }
                            else
                            {
                                if (zds >= zValueLowBoundary && zds <= zValueUpBoundary)
                                {
                                    var index = (int)((zds - zValueMin) * zRangeFactor);
                                    var c = palette.GetColor(index);
                                    byte[] bArray = BitConverter.GetBytes(c);
                                    foreach (byte b in bArray)
                                    {
                                        pixels[writeIndex] = b;
                                        writeIndex++;
                                    }
                                }
                                else
                                {
                                    writeIndex += bytesPerPixel;
                                }
                            }
                        }
                        else
                        {
                            writeIndex += bytesPerPixel;
                        }
                    }
                }
            }
            return pixels;
        }

        private static byte[] DrawRectangleWithDoubleX(int chartWidth, int chartHeight, int bpp, AbstractSurface surface,
            HeatMapPalette palette, double axisXMax, double axisXMin, double axisYMax, double axisYMin,
            double zValueUpBoundary,
            double zValueLowBoundary, double zValueMax, double zValueMin)
        {
            int bytesPerPixel = bpp / 8;

            Byte[] pixels = new byte[chartHeight * chartWidth * bytesPerPixel];
            double xRangeFactor = (axisXMax - axisXMin) / chartWidth;
            double xRangeFactorInMid = xRangeFactor / 2;
            double yRangeFactor = (axisYMax - axisYMin) / chartHeight;
            double zRangeFactor = (palette.ColorCount - 1) / (zValueMax - zValueMin);

            var xRangeMin = (double)surface.XRange.Min;
            var xRangeMax = (double)surface.XRange.Max;
            var yPixelsNum = (chartHeight - 1);
            var xAxisByteOffset = chartWidth * bytesPerPixel;

            for (int y = 0; y < chartHeight; y++)
            {
                {
                    double yds = (y + 0.5) * yRangeFactor + axisYMin;
                    double xds = -xRangeFactorInMid;
                    int writeIndex = (yPixelsNum - y) * xAxisByteOffset;
                    for (int x = 0; x < chartWidth; x++)
                    {
                        xds += xRangeFactor;
                        double input = axisXMin + xds;
                        if (input >= xRangeMin
                            && input < xRangeMax
                            && yds >= surface.YRange.Min
                            && yds < surface.YRange.Max)
                        {
                            var zds = surface.GetValue(input, yds);
                            if (double.IsNaN(zds) || zds > zValueMax || zds < zValueMin)
                            {
                                writeIndex += bytesPerPixel;
                            }
                            else
                            {
                                if (zds >= zValueLowBoundary && zds <= zValueUpBoundary)
                                {
                                    var index = (int)((zds - zValueMin) * zRangeFactor);
                                    var c = palette.GetColor(index);
                                    byte[] bArray = BitConverter.GetBytes(c);
                                    foreach (byte b in bArray)
                                    {
                                        pixels[writeIndex] = b;
                                        writeIndex++;
                                    }
                                }
                                else
                                {
                                    writeIndex += bytesPerPixel;
                                }
                            }
                        }
                        else
                        {
                            writeIndex += bytesPerPixel;
                        }
                    }
                }
            }
            return pixels;
        }
    }

    internal class DefaultSurface : AbstractSurface
    {
        Range<object> xRange = new Range<object> { Min = 0.0, Max = 360.0 };
        Range<double> yRange = new Range<double> { Min = -5.0, Max = 5.0 };
        Range<double> zRange = new Range<double> { Min = 0.3, Max = 2.3 };

        public override double GetValue(object x, double y, bool interpolation = true)
        {
            return Math.Sin(((double)x * Math.PI) / 180) + 1.3;
        }

        public override Range<Object> XRange
        {
            get { return xRange; }
        }

        public override Range<double> YRange
        {
            get { return yRange; }
        }

        public override Range<double> ZRange
        {
            get { return zRange; }
        }
    }

    internal class BlankSurface : AbstractSurface
    {
        Range<object> xRange = new Range<object> { Min = 0.0, Max = 1.0 };
        Range<double> yRange = new Range<double> { Min = 0.0, Max = 1.0 };
        Range<double> zRange = new Range<double> { Min = 0.0, Max = 1.0 };

        public override double GetValue(object x, double y, bool interpolation = true)
        {
            return double.NaN;
        }

        public override Range<Object> XRange
        {
            get { return xRange; }
        }

        public override Range<double> YRange
        {
            get { return yRange; }
        }

        public override Range<double> ZRange
        {
            get { return zRange; }
        }
    }

    public enum CHeatMapYAxisPlacementTypes
    {
        Top = 0,
        Left = 1,
        Right = 2,
        Bottom = 3
    }

    public enum RadarHeatmapOrientations
    {
        CounterClockwise = 0,
        Clockwise = 1
    }
}

